<!DOCTYPE html>

<html lang="en">

<head>
	<meta charset="utf-8"/>
    <title>Bapature Labs</title>

		<base href="/blog/blog-test/portal/">
        
    <script src="https://code.jquery.com/jquery-3.2.1.min.js" 
	integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" 
	crossorigin="anonymous"></script>
     
     
    <style>
    canvas {
        position: absolute;
        top: 20;
        left: 20;
	}
	
	#canvasDiv {
		border: 2px solid black;
		height: 600px;
		width: 960px;
		background-color: white;
	}
	</style>
    
    <script>
		
		//#################################### BASIC TEMPLATE ####################################
		
		const grdSize = 60;
		const maxMoves = 27;
		
		document.write("<div id=\"canvasDiv\">");
		document.write("<canvas id=\"mapCanvas\" width=\"960\" height=\"600\">Your browser does not support canvas.</canvas>");
		document.write("<canvas id=\"topCanvas\" width=\"960\" height=\"600\"></canvas>");
		document.write("<canvas id=\"overlayCanvas\" width=\"960\" height=\"600\"></canvas>");
		document.write("<canvas id=\"mapCanvas\" width=\"960\" height=\"600\">Your browser does not support canvas.</canvas>");
		document.write("</div>");

		var btx = document.getElementById("overlayCanvas").getContext("2d");
		var ctx = document.getElementById("mapCanvas").getContext("2d"); //Note ctx does stand for something, but I needed more id's for the canvases context and btx dtx made the most sense to me
		var dtx = document.getElementById("topCanvas").getContext("2d");
		
		function sound(src) { //taken from https://www.w3schools.com/graphics/game_sound.asp
			this.sound = document.createElement("audio");
			this.sound.src = src;
			this.sound.setAttribute("preload", "auto");
			this.sound.setAttribute("controls", "none");
			this.sound.style.display = "none";
			document.body.appendChild(this.sound);
			this.play = function(){
				this.sound.currentTime = 0;
				this.sound.play();
			}
			this.stop = function(){
				this.sound.pause();
			}
		}
		
		function drawMovesText() {
			btx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height)
			btx.fillStyle = "white";
			btx.font = "50px Arial";
			btx.fillText(moves.toString(), (overlayCanvas.width - grdSize) + 3, grdSize - 20);
		}
		
		function drawGrid(pWidth) {
			ctx.fillStyle = "black";
			for (var i = 1; i <= 50; i++) {
				draw(0,i * pWidth,2000,i * pWidth);	
				draw(i * pWidth,0,i * pWidth,2000);
			}
		}
		
		function draw(pX1, pY1, pX2, pY2){
			ctx.linewidth = 10;
			ctx.moveTo(pX1, pY1);
			ctx.lineTo(pX2, pY2);
			ctx.stroke();
		}
		
		function drawDoorHint(pX,pY) {
			dtx.fillStyle = "rgba(50,255,50,0.5)";
			dtx.fillRect(pX + 3, pY + 3, grdSize - 6, grdSize - 6);
		}
		
		function drawPortal(pColor, pX, pY) {
			dtx.setLineDash([]);
			dtx.beginPath();
			dtx.lineWidth = 10;
			dtx.arc(pX + grdSize /2 , pY + grdSize /2 , grdSize / 2 - 10, 0, 2 * Math.PI);
			dtx.strokeStyle = pColor;
			dtx.stroke();
			
			dtx.fillStyle = pColor;
			dtx.fillRect(pX, pY, 1, 1);
		}
		
		function drawButton(pIsCu, pX, pY) {
			
			dtx.fillStyle = "gray";
			dtx.fillRect(pX + 2, pY + 2, grdSize - 4, grdSize - 4);
			
			if (pIsCu) {
				
				dtx.fillStyle = "rgba(255, 50, 0, 1)";
				dtx.fillRect(pX + 6, pY + 6, grdSize - 12, grdSize - 12);

				dtx.strokeStyle = "black";
				pX = pX - -(grdSize / 2);
				pY -= -10;

				var size = grdSize - 20;
				dtx.lineWidth = 3;
				dtx.setLineDash([5]);
				dtx.beginPath();
				var topCurveHeight = size * 0.3; 
				dtx.moveTo(pX, pY + topCurveHeight);
				// top left curve
				dtx.bezierCurveTo(
					pX, pY, 
					pX - size / 2, pY, 
					pX - size / 2, pY + topCurveHeight
				);
				dtx.stroke();

				// bottom left curve
				dtx.bezierCurveTo(
					pX - size / 2, pY + (size + topCurveHeight) / 2, 
					pX, pY + (size + topCurveHeight) / 2, 
					pX, pY + size
				);
				dtx.stroke();

				// bottom right curve
				dtx.bezierCurveTo(
					pX, pY + (size + topCurveHeight) / 2, 
					pX + size / 2, pY + (size + topCurveHeight) / 2, 
					pX + size / 2, pY + topCurveHeight
				);
				dtx.stroke();

				// top right curve
				dtx.bezierCurveTo(
					pX + size / 2, pY, 
					pX, pY, 
					pX, pY + topCurveHeight
				);
				dtx.stroke();

				dtx.closePath();
				dtx.restore();
				
				
				}
			else {
				dtx.fillStyle = "rgba(0, 80, 255, 1)";
				dtx.fillRect(pX + 6, pY + 6, grdSize - 12, grdSize - 12);
			}
			
			//dtx.fillRect(pX, pY, 1, 1);
			
		}
		
		function drawPlayer(pX, pY) {
			dtx.fillStyle = "black";
			dtx.fillRect(pX + 5, pY + 5, grdSize - 10, grdSize - 10);
			dtx.fillStyle = "wheat";
			dtx.fillRect(pX + 7, pY + 7, grdSize - 14, grdSize - 14);
		}
		
		function drawSemiWall(pX, pY) {
			dtx.fillStyle = "rgba(170,170,170,1)";
			dtx.fillRect(pX, pY, 1, 1);
			
			dtx.fillStyle = "rgba(170, 170, 170, 1)";
			dtx.fillRect(pX + 1, pY + 1, grdSize - 2, grdSize - 2);
		}
		
		function drawWall(pX, pY) {
			dtx.fillStyle = "rgba(0,0,1,1)";
			dtx.fillRect(pX, pY, 1, 1);
			
			dtx.fillStyle = "black";
			dtx.fillRect(pX + 1, pY + 1, grdSize - 2, grdSize - 2);
		}
		
		function drawCube(pX, pY) { //the code to draw the heart is taken from the internet http://www.java2s.com/Tutorials/Javascript/Canvas_How_to/Shape/Draw_Spade_Heart_Club_Diamond.htm
		dtx.fillStyle = "rgba(50,50,50,1)";
		dtx.fillRect(pX, pY, 1, 1);
		
		dtx.fillStyle = "black";
		dtx.fillRect(pX + 3, pY + 3, grdSize - 6, grdSize - 6);
		dtx.fillStyle = "grey";
		dtx.fillRect(pX + 5, pY + 5, grdSize - 10, grdSize - 10);
		
		pX += grdSize / 2;
		pY += 10;
		
		var size = grdSize - 20;
		
		dtx.beginPath();
        var topCurveHeight = size * 0.3; 
                dtx.moveTo(pX, pY + topCurveHeight);
                // top left curve
                dtx.bezierCurveTo(
				
          pX, pY, 
          pX - size / 2, pY, 
          pX - size / 2, pY + topCurveHeight
        );
                
                // bottom left curve
                dtx.bezierCurveTo(
          pX - size / 2, pY + (size + topCurveHeight) / 2, 
          pX, pY + (size + topCurveHeight) / 2, 
          pX, pY + size
        );
                
                // bottom right curve
                dtx.bezierCurveTo(
          pX, pY + (size + topCurveHeight) / 2, 
          pX + size / 2, pY + (size + topCurveHeight) / 2, 
          pX + size / 2, pY + topCurveHeight
        );
                
                // top right curve
                dtx.bezierCurveTo(
			  pX + size / 2, pY, 
			  pX, pY, 
			  pX, pY + topCurveHeight
        );
                
                dtx.closePath();
                dtx.fillStyle = "pink";
                dtx.fill();
        		dtx.restore();	
		}
		
		function getCubePos() {
			var cubePos = "no";
			for (var i = 0; i < (topCanvas.height / grdSize); i++) {
					for (var r = 0; r < (topCanvas.width / grdSize); r++) {
						if (String(dtx.getImageData(r * grdSize, i * grdSize, 1, 1).data) == "0,0,0,255") { //check for portals
							//cube
							cubePos = [r * grdSize, i * grdSize];
						}
					}
				}
			return cubePos;
		}
		
		function getBluePos() {
			var bluePos = "no";
			for (var i = 0; i < (topCanvas.height / grdSize); i++) {
					for (var r = 0; r < (topCanvas.width / grdSize); r++) {
						if (String(dtx.getImageData(r * grdSize, i * grdSize, 1, 1).data) == "0,0,255,255") { //check for portals
							//Blue portal
							bluePos = [r * grdSize, i * grdSize];
						}
					}
				}
			return bluePos;
		}
		
		function getOrangePos() {
			var orangePos = "no";
			for (var i = 0; i < (topCanvas.height / grdSize); i++) {
					for (var r = 0; r < (topCanvas.width / grdSize); r++) {
						if (String(dtx.getImageData(r * grdSize, i * grdSize, 1, 1).data) == "255,165,0,255"){
							//Orange portal
							var orangePos = [r * grdSize, i * grdSize];
						}
					}
				}
			return orangePos;
		}
		
		function getWalls() {
			var walls = [];
			for (var i = 0; i < (topCanvas.height / grdSize); i++) {
					for (var r = 0; r < (topCanvas.width / grdSize); r++) {
						if (String(dtx.getImageData(r * grdSize, i * grdSize, 1, 1).data) == "0,0,1,255"){
							walls.push(r * grdSize + "|" + i * grdSize);
						}
					}
				}
			return walls;
		}
		
		function getSemiWalls() {
			var semiWalls = [];
			for (var i = 0; i < (topCanvas.height / grdSize); i++) {
					for (var r = 0; r < (topCanvas.width / grdSize); r++) {
						if (String(dtx.getImageData(r * grdSize, i * grdSize, 1, 1).data) == "170,170,170,255"){
							semiWalls.push(r * grdSize + "|" + i * grdSize);
						}
					}
				}
			return semiWalls;
		}
		
		function cubeCalculate(lastMove){
		var doPush = true;
		if (cuX == plX && cuY == plY) {
			if (cuX + lastMove[0] < 0 || cuX + lastMove[0] > topCanvas.width - 1 || cuY + lastMove[1] < 0 || cuY + lastMove[1] > topCanvas.height - 1 ) {
				doPush = false;
			}
			
			var wallList = getWalls();
			for (var i = 0; i < wallList.length; i++) {
				if (wallList[i].toString() == ((cuX + lastMove[0] + "|" + (cuY + lastMove[1])).toString()) || wallList[i].toString() == ((cuX + lastMove[0] + "|" + (cuY + lastMove[1])).toString()) || wallList[i].toString() == (((cuX + lastMove[0]) + "|" + (cuY + lastMove[1]) ).toString()) || wallList[i].toString() == (((cuX + lastMove[0]) + "|" + (cuY + lastMove[1])).toString())) {		
					doPush = false;
				}
			}
			
			wallList = getSemiWalls();
			for (var i = 0; i < wallList.length; i++) {
				if (wallList[i].toString() == ((cuX + lastMove[0] + "|" + (cuY + lastMove[1])).toString()) || wallList[i].toString() == ((cuX + lastMove[0] + "|" + (cuY + lastMove[1])).toString()) || wallList[i].toString() == (((cuX + lastMove[0]) + "|" + (cuY + lastMove[1]) ).toString()) || wallList[i].toString() == (((cuX + lastMove[0]) + "|" + (cuY + lastMove[1])).toString())) {		
					doPush = false;
				}
			}
				if (!doPush) {
					plX -= lastMove[0];
					plY -= lastMove[1];	
				}
				if (doPush) {
					dtx.clearRect(cuX, cuY, grdSize, grdSize);
					cuX += lastMove[0];
					cuY += lastMove[1];	
				}
			}
		}
		
		function getCursorPosition(pCanvas, event, pPortalColor) { 
			const rect = pCanvas.getBoundingClientRect();
			const mousX = event.clientX - rect.left;
			const mousY = event.clientY - rect.top;

			var portalX = Math.floor(mousX/grdSize);
			var portalY = Math.floor(mousY/grdSize);
			
			
			if ((portalX * grdSize - plX) > (-grdSize - 1) && (portalX * grdSize - plX) < (grdSize + 1) && (portalY * grdSize - plY) < (grdSize + 1) && (portalY * grdSize - plY) > (-grdSize - 1)){ //check if portal is close enough to player
				if (!(portalX * grdSize == plX) || !(portalY * grdSize == plY)) { //check if portal hits player
					if (!(portalX * grdSize == cuX) || !(portalY * grdSize == cuY)) { //check if portal hits cube
						if (!(portalX * grdSize == bupX) || !(portalY * grdSize == bupY)) { //check if portal player button
							if (!(portalX * grdSize == bucX) || !(portalY * grdSize == bucY)) { //check if portal cube button

								var wallList = getWalls();
								var doPortal = true;
								for (var i = 0; i < wallList.length; i++) {
									if ((wallList[i].toString() == ((portalX * grdSize) + "|" + (portalY * grdSize)).toString())) { //checking for walls
										doPortal = false;
									}
								}
								
								wallList = getSemiWalls();
								for (var i = 0; i < wallList.length; i++) {
									if ((wallList[i].toString() == ((portalX * grdSize) + "|" + (portalY * grdSize)).toString())) { //checking for semi-walls
										doPortal = false;
									}
								}
								if (doPortal){
									if(!(getBluePos() == "no") && pPortalColor == "rgba(0,0,255,1)"){ //check for (and delets if applicable) pre-existing portal
										var bluePos = getBluePos();
										dtx.clearRect(bluePos[0], bluePos[1], grdSize, grdSize);
									}
									else if (!(getOrangePos() == "no") && pPortalColor == "rgba(255,165,0,1)"){
										var orangePos = getOrangePos();
										dtx.clearRect(orangePos[0], orangePos[1], grdSize, grdSize);
									}
									drawPortal(pPortalColor, portalX * grdSize, portalY * grdSize);
									if (!bupDown) {
									drawPortal("rgba(50,255,50,1)", drX, drY);
									}
									else {
										dtx.clearRect(drX, drY, grdSize, grdSize);//clear door hint so it remains the same opacity
										drawDoorHint(drX, drY);
									}
									drawPlayer(plX, plY);
								}
							}
						}
					}
				}
			}
		}
		
		const canvas = document.querySelector('canvas');
		$("canvas").on('mousedown', function(event) {
			switch (event.which) {
				case 1:
					//LMB
					getCursorPosition(canvas, event, "rgba(0,0,255,1)");
					break;
				case 2:
					//MMB
					getCursorPosition(canvas, event, "rgba(255,165,0,1)");
					break;
				case 3:
					//RMB
					break;
				default:
					alert('Mouse not recognised, please change mouse.');
			}
		});
		
		$(document).on("keypress", function (e) {
			
			if (e.which == 97 || e.which == 100 || e.which == 115 || e.which == 119) {	
				//run before move here
				stepS.play();
				
				dtx.clearRect(plX, plY, grdSize, grdSize); //################################## IF GRID IS NOT THE SAME SIZE AS PLAYER CHANGE grdSize TO THE PLAYER'S SIZE - Past Nate ##################################
				var doMove = true;
			}
			
			if (e.which == 32) {
				//space bar
				var orangePos = getOrangePos();
				var bluePos = getBluePos();
				
				dtx.clearRect(orangePos[0], orangePos[1], grdSize, grdSize);
				dtx.clearRect(bluePos[0], bluePos[1], grdSize, grdSize);
			}
			
			if (e.which == 119) {
				//w
				if (!(plY - grdSize < -1 || moves <= 0)){ //conditions to not allow a move		
					var wallList = getWalls();
					for (var i = 0; i < wallList.length; i++) {
						if (wallList[i].toString() == ((plX + "|" + (plY - grdSize)).toString())) {
							doMove = false;
						}
					}
					if (doMove) {
						plY -= grdSize;
						var lastMove = [0, -grdSize];	
					}
				}
			}
			if (e.which == 115) {
				//s
				if (!(plY + grdSize > topCanvas.height - 1 || moves <= 0)){ //conditions to not allow a move
					var wallList = getWalls();
					for (var i = 0; i < wallList.length; i++) {
						if (wallList[i].toString() == ((plX + "|" + (plY + grdSize)).toString())) {
							doMove = false;
						}
					}
					if (doMove) {
						plY += grdSize;
						var lastMove = [0, grdSize];	
					}
				}
			}
			if (e.which == 100) {
				//d
				if (!(plX + grdSize > topCanvas.width - 1 || moves <= 0)){ //conditions to not allow a move
					var wallList = getWalls();
					for (var i = 0; i < wallList.length; i++) {
						if (wallList[i].toString() == (((plX + grdSize) + "|" + plY ).toString())) {
							doMove = false;
						}
					}
					if (doMove) {
						plX += grdSize;
						var lastMove = [grdSize, 0];	
					}
				}
			}
			if (e.which == 97) {
				//a
				if (!(plX - grdSize < -1|| moves <= 0)){ //conditions to not allow a move
					var wallList = getWalls();
					for (var i = 0; i < wallList.length; i++) {
						if (wallList[i].toString() == (((plX - grdSize) + "|" + plY).toString())) {
							doMove = false;
						}
					}
					if (doMove) {
						plX -= grdSize;
						var lastMove = [-grdSize, 0];	
					}
				}
			}
							
			if (e.which == 97 || e.which == 100 || e.which == 115 || e.which == 119) {
				//any thing to run after move goes here
				
				cubeCalculate(lastMove);
				
				//####### teleport #########
				var orangePos = getOrangePos();
				var bluePos = getBluePos();
				
				
				//Player teleport
				if (plX == orangePos[0] && plY == orangePos[1] && !(bluePos == "no")) {
					if (bluePos[0] + lastMove[0] < 0 || bluePos[0] + lastMove[0] > topCanvas.width - 1 || bluePos[1] + lastMove[1] < 0 || bluePos[1] + lastMove[1] > topCanvas.height - 1 ){//makes sure you can't teleport out of bounds
					}
					else {
						var tele = true;
						var wallList = getWalls();
						for (var i = 0; i < wallList.length; i++) {
							if (wallList[i].toString() == ((bluePos[0] + lastMove[0] + "|" + (bluePos[1] + lastMove[1])).toString())) {		
								tele = false;
							}
						}
						if (tele) {
							plX = bluePos[0] + lastMove[0];
							plY = bluePos[1] + lastMove[1];
							teleportS.play();
						}
					}
				}
				
				if (plX == bluePos[0] && plY == bluePos[1] && !(orangePos == "no")) {
					if (orangePos[0] + lastMove[0] < 0 || orangePos[0] + lastMove[0] > topCanvas.width - 1 || orangePos[1] + lastMove[1] < 0 || orangePos[1] + lastMove[1] > topCanvas.height - 1 ){//makes surew you can't teleport out of bounds	
					}
					else {
						var tele = true;
						var wallList = getWalls();
						for (var i = 0; i < wallList.length; i++) {
							if (wallList[i].toString() == ((orangePos[0] + lastMove[0] + "|" + (orangePos[1] + lastMove[1])).toString())) {		
								var tele = false;
							}
						}
						if (tele) {
							plX = orangePos[0] + lastMove[0];
							plY = orangePos[1] + lastMove[1];
							teleportS.play();
						}
					}
				}
				
				var orangePos = getOrangePos();
				var bluePos = getBluePos();
				//Cube teleport
				if (cuX == orangePos[0] && cuY == orangePos[1] && !(bluePos == "no")) {
					if (bluePos[0] + lastMove[0] < 0 || bluePos[0] + lastMove[0] > topCanvas.width - 1 || bluePos[1] + lastMove[1] < 0 || bluePos[1] + lastMove[1] > topCanvas.height - 1 ){//makes surew you can't teleport out of bounds
					}
					else {
						var tele = true;
						var wallList = getWalls();
						for (var i = 0; i < wallList.length; i++) {
							if (wallList[i].toString() == ((bluePos[0] + lastMove[0] + "|" + (bluePos[1] + lastMove[1])).toString())) {		
								var tele = false;
							}
						}
						if (tele) {
							var wallList = getSemiWalls();
							for (var i = 0; i < wallList.length; i++) {
								if (wallList[i].toString() == ((bluePos[0] + lastMove[0] + "|" + (bluePos[1] + lastMove[1])).toString())) {		
									var tele = false;
								}
							}
						}
						if (tele) {
							cuX = bluePos[0] + lastMove[0];
							cuY = bluePos[1] + lastMove[1];
							teleportS.play();
						}
					}
				}
				
				if (cuX == bluePos[0] && cuY == bluePos[1] && !(orangePos == "no")) {
					if (orangePos[0] + lastMove[0] < 0 || orangePos[0] + lastMove[0] > topCanvas.width - 1 || orangePos[1] + lastMove[1] < 0 || orangePos[1] + lastMove[1] > topCanvas.height - 1 ){//makes surew you can't teleport out of bounds	
					}
					else {
						var tele = true;
						var wallList = getWalls();
						for (var i = 0; i < wallList.length; i++) {
							if (wallList[i].toString() == ((orangePos[0] + lastMove[0] + "|" + (orangePos[1] + lastMove[1])).toString())) {		
								var tele = false;
							}
						}
						if (tele) {
							var wallList = getSemiWalls();
							for (var i = 0; i < wallList.length; i++) {
								if (wallList[i].toString() == ((orangePos[0] + lastMove[0] + "|" + (orangePos[1] + lastMove[1])).toString())) {		
									var tele = false;
								}
							}
						}
						if (tele) {
							cuX = orangePos[0] + lastMove[0];
							cuY = orangePos[1] + lastMove[1];
							teleportS.play();
						}
					}
				}
				
				//##########################
				
				cubeCalculate(lastMove);
				
				if (bucX == cuX && bucY == cuY) {
					bucPress();
				}
				
				if (buc2X == cuX && buc2Y == cuY) {
					buc2Press();
				}
				
				if (bupX == plX && bupY == plY) {
					bupPress();
				}
				
				if (bup2X == plX && bup2Y == plY) {
					bup2Press();
				}
				
				moves --;
				
				//Drawing all the things that can feesably be on top of one another
				
				if (!(String(dtx.getImageData(drX, drY, 1, 1).data) == "50,255,50,255")) {
					dtx.clearRect(drX, drY, grdSize, grdSize);//clear door hint so it remains the same opacity
					drawDoorHint(drX, drY);
				}
				else {
					dtx.clearRect(drX, drY, grdSize, grdSize);//clear exit portal so it remains the same opacity
					drawPortal("rgba(50,255,50,1)", drX, drY);
				}
				
				if (!bupDown) {
					drawPortal("rgba(50,255,50,1)", drX, drY);
				}
				else {
					dtx.clearRect(drX, drY, grdSize, grdSize);//clear door hint so it remains the same opacity
					drawDoorHint(drX, drY);
				}
				
				drawButton(false, bupX, bupY);
				drawButton(false, bup2X, bup2Y);
				drawButton(true, bucX, bucY);
				drawButton(true, buc2X, buc2Y);
				drawCube(cuX,cuY);
				drawPlayer(plX, plY);
				drawMovesText();
				
				if (plX == drX && plY == drY) {//Check for moving to next room
					if (String(dtx.getImageData(drX, drY, 1, 1).data) == "50,255,50,255") { //check exit portal existing
						//enter portal
						window.location.href = "badEnding.html";
					}
				}
			}
			
			if (e.which == 114 || moves <= 0) {
				//r
				dtx.clearRect(0, 0, topCanvas.width, topCanvas.height);
				restartS.play();
				start();
			}
		});
		
		function rando(pMin, pMax) {
			var number = Math.floor(Math.random() * (pMax - pMin + 1)) + pMin;	
			return number;
		}
		
		//#################################### END OF BASIC TEMPLATE ####################################
		
		function bucPress() {
			//runs on cube button press
			if (bucDown) {
				//runs on first press only
				buttonS.play();
				bucDown = false;
				//remove the walls
				dtx.clearRect(grdSize * 5, grdSize * 5, grdSize, grdSize * 5);
				dtx.clearRect(grdSize * 6, grdSize * 7, grdSize, grdSize * 3);
				dtx.clearRect(grdSize * 2, grdSize * 4, grdSize, grdSize);
				dtx.clearRect(grdSize * 1, grdSize * 5, grdSize, grdSize);
				dtx.clearRect(grdSize * 5, grdSize * 4, grdSize, grdSize);
				
				dtx.clearRect(grdSize * 11, grdSize * 0, grdSize, grdSize * 3);
				dtx.clearRect(grdSize * 11, grdSize * 3, grdSize * 5, grdSize);
			}
		}
		
		function buc2Press() {
			//runs on cube button press
			if (buc2Down) {
				//runs on first press only
				buttonS.play();
				buc2Down = false;
				//remove the walls
				moves += 3;
				dtx.clearRect(grdSize * 13, grdSize * 0, grdSize, grdSize * 3);
				dtx.clearRect(grdSize * 13, grdSize * 1, grdSize * 3, grdSize);
			}
		}
		
		function bupPress() {
			//runs on player button press
			if (bupDown) {
				//runs on first press only
				buttonS.play();
				bupDown = false;
				drawPortal("rgba(50,255,50,1)", drX, drY);
			}
		}
		
		function bup2Press() {
			//runs on player button2 press
			if (bup2Down) {
				//runs on first press only
				buttonS.play();
				bup2Down = false;
				dtx.clearRect(grdSize * 12, grdSize * 0, grdSize, grdSize * 3);
				dtx.clearRect(grdSize * 12, grdSize * 2, grdSize * 5, grdSize);
			}
		}
		
		var plX;
		var plY;
		
		var cuX;
		var cuY;
		
		var drX;
		var drY;
		
		var bucX;
		var bucY;
		var bucDown;
		
		var buc2X;
		var buc2Y;
		var buc2Down;
		
		var bupX;
		var bupY;
		var bupDown;
		
		var bup2X;
		var bup2Y;
		var bup2Down;
		
		var stepS = new sound("sounds/step.wav");
		var buttonS = new sound("sounds/button.wav");
		var restartS = new sound("sounds/restart.wav");
		var teleportS = new sound("sounds/teleport.wav");
		
		function start() {
			moves = maxMoves;
			
			drawWall(grdSize * 15, 0);
			
			drX = grdSize * 14;
			drY = grdSize * 0;
			drawDoorHint(drX, drY);
			
			plX = grdSize * 1;
			plY = grdSize * 9;
			
			cuX = grdSize * 1;
			cuY = grdSize * 8;
			
			bucX = grdSize * 4;
			bucY = grdSize * 5;
			drawButton(true, bucX, bucY);
			bucDown = true;
			
			buc2X = grdSize * 11;
			buc2Y = grdSize * 8;
			drawButton(true, buc2X, buc2Y);
			buc2Down = true;
			
			bupX = grdSize * 5;
			bupY = grdSize * 8;
			bupDown = true;
			drawButton(false, bupX, bupY);
			
			bup2X = grdSize * 4;
			bup2Y = grdSize * 0;
			bup2Down = true;
			drawButton(false, bup2X, bup2Y);
			
			//WALLS ########################################
			
			//Around door
			drawWall(grdSize * 13, grdSize * 0);
			drawWall(grdSize * 12, grdSize * 0);
			drawWall(grdSize * 11, grdSize * 0);
			
			drawWall(grdSize * 15, grdSize * 1);
			drawWall(grdSize * 14, grdSize * 1);
			drawWall(grdSize * 13, grdSize * 1);
			drawWall(grdSize * 12, grdSize * 1);
			drawWall(grdSize * 11, grdSize * 1);

			drawWall(grdSize * 15, grdSize * 2);
			drawWall(grdSize * 14, grdSize * 2);
			drawWall(grdSize * 13, grdSize * 2);
			drawWall(grdSize * 12, grdSize * 2);
			drawWall(grdSize * 11, grdSize * 2);
			
			drawWall(grdSize * 15, grdSize * 3);
			drawWall(grdSize * 14, grdSize * 3);
			drawWall(grdSize * 13, grdSize * 3);
			drawWall(grdSize * 12, grdSize * 3);
			drawWall(grdSize * 11, grdSize * 3);

			
			//Bottom left
			drawWall(grdSize * 0, grdSize * 6);
			drawWall(grdSize * 1, grdSize * 6);
			drawWall(grdSize * 1, grdSize * 5);
			drawWall(grdSize * 2, grdSize * 5);
			drawWall(grdSize * 2, grdSize * 4);
			drawWall(grdSize * 3, grdSize * 4);
			drawWall(grdSize * 4, grdSize * 4);
			
			drawWall(grdSize * 5, grdSize * 0);
			drawWall(grdSize * 5, grdSize * 1);
			drawWall(grdSize * 5, grdSize * 2);
			drawWall(grdSize * 5, grdSize * 3);
			drawWall(grdSize * 5, grdSize * 4);
			drawWall(grdSize * 5, grdSize * 5);
			drawWall(grdSize * 5, grdSize * 6);
			drawWall(grdSize * 5, grdSize * 7);
			drawWall(grdSize * 5, grdSize * 9);
			
			drawWall(grdSize * 6, grdSize * 7);
			drawWall(grdSize * 6, grdSize * 8);
			drawWall(grdSize * 6, grdSize * 9);
			
			//top left
			drawWall(grdSize * 2, grdSize * 0);
			drawWall(grdSize * 2, grdSize * 1);
			
			drawWall(grdSize * 3, grdSize * 0);
			drawWall(grdSize * 3, grdSize * 1);
			
			drawWall(grdSize * 1, grdSize * 1);
			
			drawWall(grdSize * 0, grdSize * 2);
			drawWall(grdSize * 1, grdSize * 2);
			
			//filler
			drawWall(grdSize * 6, grdSize * 0);
			drawWall(grdSize * 9, grdSize * 0);
			
			drawWall(grdSize * 7, grdSize * 1);
			drawWall(grdSize * 9, grdSize * 1);
			drawWall(grdSize * 10, grdSize * 1);
			
			drawWall(grdSize * 10, grdSize * 2);
			
			drawWall(grdSize * 7, grdSize * 3);
			drawWall(grdSize * 8, grdSize * 3);
			drawWall(grdSize * 8, grdSize * 4);
			drawWall(grdSize * 9, grdSize * 3);
			
			drawWall(grdSize * 9, grdSize * 6);
			
			drawWall(grdSize * 12, grdSize * 7);
			drawWall(grdSize * 15, grdSize * 7);
			
			drawWall(grdSize * 13, grdSize * 8);
			
			drawWall(grdSize * 12, grdSize * 9);
			drawWall(grdSize * 14, grdSize * 9);
			
			//############################################
			
			drawGrid(grdSize);
			
			drawCube(cuX,cuY);
			
			drawPlayer(plX, plY);
			
			drawMovesText();
		}
		
		start();
		cutScene();
		
		function cutScene() {
			document.body.style.background = sessionStorage.getItem("backgroundC");
			
			if (sessionStorage.getItem("devMode") == "true"){
				document.write("<button onClick=\"moves = 99\">I can't beat this, give me more lives</button>");
			}
			
			var voiceRan = sessionStorage.getItem("cutSceneRan");
			
			$(document).on("keypress", function (e) {
				
				if (voiceRan == "false") {
					//atx.fillStyle = "black";
					//atx.fillRect(0,0,textCanvas.width,textCanvas.height)	
					
					var msg = new SpeechSynthesisUtterance("Welcome, " + sessionStorage.getItem("prefix") + sessionStorage.getItem("name") + " to the final challenge!");
					msg.rate = sessionStorage.getItem("textSpd"); // 0.1 to 10
					msg.pitch = 0.2;
					
					window.speechSynthesis.speak(msg);
					
					voiceRan = true;
				}
			});
		}
		
		
    </script>
    
<body>

</body>

</html>


